<?XML version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <HEAD>
    <TITLE>Freedup Download</TITLE>
    <META HTTP-equiv="Content-Type" content="text/html; charset=utf-8" />
    <META NAME="KEYWORDS" content="Freedup, systems management, tool, link, download" />
    <META HTTP-EQUIV="expires" content="Tue, 30 Aug 2007 19:00:00 CET" />
    <LINK REL="stylesheet" type="text/css" href="freedup.css" />
</HEAD>
<BODY BGCOLOR="#DDDDFF">
<P>
<H2> How freedup in principle works </H2>
<P>
There are neither warranties nor guarantees for freedup working correctly. 
In principle freedup only knows about linking. Therefore the maximum risk is to link different files.
During development many precautions were taken, but I have to emphasize that this risk exists.
Only when using interactive mode you may delete files in a two step process, too.
If you detect any possible source of misbehaviour in freedup, please report it for the sake of all users.
<P>
In principle freedup always searches for files of identical size and compares them byte-by-byte.
The only exception are "extra styles", where the tags (details see next chapter) are intentionally skipped.
Before files are compared byte-by-byte you might apply restrictions, like being owned
by the same group or user, having the same permission or whatever the options allow you.
Files that match in content and fulfil all required prerequisites are linked in the demanded way.
<P>
<OL>
<LI> Scan all directory trees recursively for all regular files.
<LI> Build a sequential list of those files and keep their name.
<LI> The arg position or pipe input sequence is kept by adding sequence numbers th each file.
<LI> Use lstat() on each file to read and store its size with the filename.
<LI> Sort the file and its attached information by comparing their sizes using qsort().
<LI> In case the comparison has to report equal file size additional properties are compared.
<LI> Most of those property checks are switched off by default.
<LI> If all demands are fullfilled, the files are compared block by block (4k).
<LI> If both files are identical and on the same file system they are added to <EM>link list</EM>.
<LI> The <EM>link list</EM> will not be processed before all comparisons are complete.
<LI> After all files are compared freedup starts processing the <EM>link list</EM>.
<LI> For each <EM>link list</EM> entry, i.e. a set of identical files, the requested order is prepared.
<LI> In interactive mode the files are now presented to make your file specific choice.
<LI> The files that are intended to be linked, will be renamed, hard linked, renamed file removed.
<LI> If hardlinking is not possible soft links are tried, 
	 except one of the paths is not starting at root (but can be forced)
<LI> Finally a short report is delivered.
</OL>
<P>
For more details please have a look into the source code or ask the author.
<P>
<H2> How freedup "extra styles" work </H2>
<P>
This concept was introduced in version 1.1 due to the fact that I wanted files to be
linked although they differed. I am talking of mp3 files where the tags showed minor
variations. First I considered retagging all files, but I would have to remove either 
all or complete all tags (n.b. MP3v1 tags are at the end, MP3v2 tags are at the
beginning of an mp3 file, both are optional).
<P>
The extra style now should compare the essential file content, i.e. the 
mpeg encoded sound part in case of the mp3 files. Currently the following
rules are established:
<UL>
<LI><B>mp3</B> strips the mp3v1 and mp3v2 tags and provides comparison of the remaining body.
<LI><B>mp4</B> strips all sections up to the first <TT>mdat</TT> section and everything 
	including the first non-<TT>mdat</TT> section after it. This should work for
	iPod files, AAC/FAAC encoded sounds, and files usually having extensions like MP4, M4A, M4V, MOV, etc.
<LI><B>mpc</B> strips the the <TT>APETAGEX</TT> labeled tail from mousepack audio files.
<LI><B>ogg</B> strips all infos until the sequence "vorbis.BCV" where the dot is arbitrary.
	Minor trailing infos (less than 128 bytes) are also cut off.
<LI><B>jpg</B> tries to strip the comments at the beginning of each file. Since some comments
	where after the quantization table, this is stripped, too.
</UL>
since for each file type exactly one method exists (might change in future),
an automated mode will call the respective method according to the file magic.
The name of each file is not considered for type checking.
<P>
Please note, that these styles change the behaviour according to the file contents.
The change the size of the compared contents, but this does not affect the options
that belong to the files, like ownerships or file names.
<P>
If you like to contribute, this is quite simple. There are source files for each style.
Start with a copy of my.c and my.h. Rename the functions, fill in your way to evaluate
the irrelevant bytes at start and the trailing ones, as well as a way to find size and magic.
Add a matching line to the extra[] table in auto.c, compile, test and submit to me.
<P>
<H2> Why freedup does not use hash functions by default </H2>
<P>
Hash functions should speed up freedup since they avoid comparing files that have been scanned before
(and might differ in the last characters). But freedup is slowed down, if files of the same size differ early.
Then you should switch the hash function off, which is now the default. If most files of the same size
are likely to be identical (more then just two), it probably pays to switch hash functions on.
There is an internal hash function that allows some interesting speed enhancements (see below).
External hash functions are kept, since they might be interesting to check the internal one for correctness.
<P>
The new algorithm records hash sums on the fly (starting in version 1.3-1)
and is in worst case - depending on cpu - half as fast as without using hash functions.
When reading files the hash function is calculated until the comparison fails.
The hash context is stored until the next comparison takes place and
if it fails at a later block, the hash calculation will be
continued where it stopped earlier.  Since reading and comparing files works
with data blocks (predefined 4k) the hash values can sometimes be calculated
although the comparison fails.
<P>
<TABLE BORDER="0" WIDTH="500">
<TR><TD COLSPAN="5"><B><TT>time ./freedup -x mp3 --hash ? -ni /testdir</TT></B><BR>
7856 files; 1 match; average file size 46MB; 50% smaller 4k; 2900 BogoMIPS<BR>
2852 classic hash sums to avoid 3411 byte-by-byte comparisons.</TD></TR>
<TR CLASS="emp"><TH>hash support</TH><TH>Parameter</TH><TH>Real Time</TH><TH>User Time</TH><TH>Sys Time</TH></TR>
<TR CLASS="emp"><TH>without hash support</TH><TD><TT>--hash 0</TT></TD><TD ALIGN="right">2m04.646s</TD><TD ALIGN="right">0m00.599s</TD><TD ALIGN="right">0m03.455s</TH></TR>
<TR CLASS="emp"><TH>with classic hashsum</TH><TD><TT>--hash 1</TT></TD><TD ALIGN="right">5m31.221s</TD><TD ALIGN="right">2m21.914s</TD><TD ALIGN="right">0m16.303s</TH></TR>
<TR CLASS="emp"><TH>with advanced hash</TH><TD><TT>--hash 2</TT></TD><TD ALIGN="right">1m59.720s</TD><TD ALIGN="right">0m06.006s</TD><TD ALIGN="right">0m03.515s</TH></TR>
</TABLE>
<P>
<TABLE BORDER="0" WIDTH="500">
<TR><TD COLSPAN="5"><B><TT>time ./freedup --hash ? -n /mp3dir</TT></B><BR>
7919 files; 0 matches; all around average file size 4.5MB; 1400 BogoMIPS<BR>
4502 classic hash sums to avoid 3819 byte-by-byte comparisons.</TD></TR>
<TR CLASS="emp"><TH>hash support</TH><TH>Parameter</TH><TH>Real Time</TH><TH>User Time</TH><TH>Sys Time</TH></TR>
<TR CLASS="emp"><TH>without hash support</TH><TD><TT>--hash 0</TT></TD><TD ALIGN="right">5m21.690s</TD><TD ALIGN="right">0m15.130s</TD><TD ALIGN="right">0m25.560s</TD></TR>
<TR CLASS="emp"><TH>with classic hashsum</TH><TD><TT>--hash 1</TT></TD><TD ALIGN="right">45m14.048s</TD><TD ALIGN="right">36m33.470s</TD><TD ALIGN="right">2m29.380s</TD></TR>
<TR CLASS="emp"><TH>with advanced hash</TH><TD><TT>--hash 2</TT></TD><TD ALIGN="right">10m01.311s</TD><TD ALIGN="right">6m28.610s</TD><TD ALIGN="right">0m28.150s</TD></TR>
</TABLE>
<P>
<TABLE BORDER="0" WIDTH="500">
<TR><TD COLSPAN="5"><B><TT>time ./freedup --hash ? -x mp3 -n /mp3dir</TT></B><BR>
7919 files; 456 duplicates; all around average file size 4.5MB; 1400 BogoMIPS<BR>
4524 classic hash sums to avoid 3425 byte-by-byte comparisons.</TD></TR>
<TR CLASS="emp"><TH>hash support</TH><TH>Parameter</TH><TH>Real Time</TH><TH>User Time</TH><TH>Sys Time</TH></TR>
<TR CLASS="emp"><TH>without hash support</TH><TD><TT>--hash 0</TT></TD><TD ALIGN="right">6m48.276s</TD><TD ALIGN="right">0m18.590s</TD><TD ALIGN="right">0m28.600s</TD></TR>
<TR CLASS="emp"><TH>with classic hashsum</TH><TD><TT>--hash 1</TT></TD><TD ALIGN="right">49m35.108s</TD><TD ALIGN="right">37m06.450s</TD><TD ALIGN="right">2m47.400s</TD></TR>
<TR CLASS="emp"><TH>with advanced hash</TH><TD><TT>--hash 2</TT></TD><TD ALIGN="right">12m33.688s</TD><TD ALIGN="right">6m51.530s</TD><TD ALIGN="right">0m31.090s</TD></TR>
</TABLE>
<P>
As a consequence of these results, the advantage of hash functions is not obvious for most environments.
I assume that there are situations, where many files have the same size and quite similar contents.
Then one should switch hash function usage to the advanced mode. But since I do not intend to rely on
hash results without having byte-by-byte comparison, I changed the default value since freedup 1.3-2 to off.
<P>

</BODY>
